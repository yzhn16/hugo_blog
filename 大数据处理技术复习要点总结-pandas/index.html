<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
    <title>大数据处理技术复习要点总结 - yzhn&#39;s Notes</title><meta name="author" content="">
<meta name="author-link" content="">
<meta name="description" content="本文就『Lending Club贷款数据转换与融合』、『行星数据分组与聚合』以及『德国能源数据时间序列分析』等案例对Pandas中的部分分析方法以及机器学习中部分算法进行总结。" />
<meta name="keywords" content="" /><meta itemprop="name" content="大数据处理技术复习要点总结">
<meta itemprop="description" content="本文就『Lending Club贷款数据转换与融合』、『行星数据分组与聚合』以及『德国能源数据时间序列分析』等案例对Pandas中的部分分析方法以及机器学习中部分算法进行总结。"><meta itemprop="datePublished" content="2021-05-25T13:39:00+00:00" />
<meta itemprop="dateModified" content="2021-05-25T13:39:00+00:00" />
<meta itemprop="wordCount" content="10815"><meta itemprop="image" content="/logo.png"/>
<meta itemprop="keywords" content="" /><meta property="og:title" content="大数据处理技术复习要点总结" />
<meta property="og:description" content="本文就『Lending Club贷款数据转换与融合』、『行星数据分组与聚合』以及『德国能源数据时间序列分析』等案例对Pandas中的部分分析方法以及机器学习中部分算法进行总结。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/" /><meta property="og:image" content="/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-25T13:39:00+00:00" />
<meta property="article:modified_time" content="2021-05-25T13:39:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="/logo.png"/>

<meta name="twitter:title" content="大数据处理技术复习要点总结"/>
<meta name="twitter:description" content="本文就『Lending Club贷款数据转换与融合』、『行星数据分组与聚合』以及『德国能源数据时间序列分析』等案例对Pandas中的部分分析方法以及机器学习中部分算法进行总结。"/>
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#252627"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/" /><link rel="prev" href="/2021%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8Cfintech%E7%B2%BE%E8%8B%B1%E8%AE%AD%E7%BB%83%E8%90%A5-%E6%95%B0%E6%8D%AE%E8%B5%9B%E9%81%93/" /><link rel="next" href="/2021%E4%B8%AD%E5%9B%BD%E9%AB%98%E6%A0%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A4%A7%E8%B5%9B%E5%BE%AE%E4%BF%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8C%91%E6%88%98%E8%B5%9B/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "大数据处理技术复习要点总结",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "\/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas\/"
    },"genre": "posts","wordcount":  10815 ,
    "url": "\/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas\/","datePublished": "2021-05-25T13:39:00+00:00","dateModified": "2021-05-25T13:39:00+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "作者"
      },"description": ""
  }
  </script></head>
  <body header-desktop="sticky" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script><div class="wrapper"><header class="desktop" id="header-desktop">
  <div class="header-wrapper" github-corner="right">
    <div class="header-title">
      <a href="/" title="yzhn&#39;s Notes"><img
    class="lazyload logo"
    src="/svg/loading.min.svg"
    data-src="/images/fixit.svg"
    data-srcset="/images/fixit.svg, /images/fixit.svg 1.5x, /images/fixit.svg 2x"
    data-sizes="auto"
    alt="yzhn&#39;s Notes"
    title="yzhn&#39;s Notes" /><span class="header-title-text">yzhn&#39;s Notes</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li
              class="menu-item"
              
            >
              <a
                class="menu-link"
                href="/posts/"
                
                
              >文章</a></li><li
              class="menu-item"
              
            >
              <a
                class="menu-link"
                href="/categories/"
                
                
              >分类</a></li><li
              class="menu-item"
              
            >
              <a
                class="menu-link"
                href="/tags/"
                
                
              >标签</a></li><li
              class="menu-item"
              
            >
              <a
                class="menu-link"
                href="/about"
                
                
              >关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="搜索文章标题或内容 ..." id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
              <i class="fa-solid fa-search fa-fw"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
              <i class="fa-solid fa-times-circle fa-fw"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin"></i>
            </span>
          </li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw"></i>
        </li>
      </ul>
    </nav>
  </div>
</header><header class="mobile" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="yzhn&#39;s Notes"><img
    class="lazyload logo"
    src="/svg/loading.min.svg"
    data-src="/images/fixit.svg"
    data-srcset="/images/fixit.svg, /images/fixit.svg 1.5x, /images/fixit.svg 2x"
    data-sizes="auto"
    alt="/images/fixit.svg"
    title="/images/fixit.svg" /><span class="header-title-text">yzhn&#39;s Notes</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="搜索文章标题或内容 ..." id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                <i class="fa-solid fa-search fa-fw"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                <i class="fa-solid fa-times-circle fa-fw"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              取消
            </a>
          </li><li
              class="menu-item"
            ><a
                class="menu-link"
                href="/posts/"
                
                
              >文章</a></li><li
              class="menu-item"
            ><a
                class="menu-link"
                href="/categories/"
                
                
              >分类</a></li><li
              class="menu-item"
            ><a
                class="menu-link"
                href="/tags/"
                
                
              >标签</a></li><li
              class="menu-item"
            ><a
                class="menu-link"
                href="/about"
                
                
              >关于</a></li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw"></i>
        </li></ul>
    </nav>
  </div>
</header>
<div class="search-dropdown desktop">
  <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
  <div id="search-dropdown-mobile"></div>
</div>
<main class="container-reverse" page-style="normal"><aside class="toc" id="toc-auto"><h2 class="toc-title">目录</h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom">
    
  </aside>

  <article class="page single"><h1 class="single-title animate__animated animate__flipInX">大数据处理技术复习要点总结</h1><div class="post-meta">
      
      <div class="post-meta-line"><span title=2021-05-25&#32;13:39:00>
            <i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="May 25, 2021" >May 25, 2021</time>
          </span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 10815 字&nbsp;
        <i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 22 分钟&nbsp;</div>
    </div><div class="details toc" id="toc-static" kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#lending-club贷款数据转换与融合">Lending Club贷款数据转换与融合</a>
      <ul>
        <li><a href="#数据源">数据源</a></li>
        <li><a href="#随机采样sample">随机采样(sample)</a></li>
        <li><a href="#数据融合mergejoin">数据融合(merge,join)</a>
          <ul>
            <li><a href="#merge">merge</a></li>
            <li><a href="#join">join</a></li>
          </ul>
        </li>
        <li><a href="#排序sort_indexsort_values">排序(sort_index,sort_values)</a></li>
        <li><a href="#离散化cutqcut">离散化(cut,qcut)</a>
          <ul>
            <li><a href="#cut">cut</a></li>
            <li><a href="#qcut">qcut</a></li>
          </ul>
        </li>
        <li><a href="#值替换replacemap">值替换(replace,map)</a>
          <ul>
            <li><a href="#map">map</a></li>
          </ul>
        </li>
        <li><a href="#哑变量处理get_dummies">哑变量处理(get_dummies)</a></li>
        <li><a href="#添加常数项列concat">添加常数项列(concat)</a></li>
      </ul>
    </li>
    <li><a href="#行星数据分组与聚合">行星数据分组与聚合</a>
      <ul>
        <li><a href="#数据源-1">数据源</a></li>
        <li><a href="#数据分组">数据分组</a>
          <ul>
            <li><a href="#通过特征分组">通过特征分组</a></li>
            <li><a href="#通过函数分组">通过函数分组</a></li>
          </ul>
        </li>
        <li><a href="#groupby对象的基本操作">GroupBy对象的基本操作</a>
          <ul>
            <li><a href="#对分组进行迭代">对分组进行迭代</a></li>
            <li><a href="#选择指定特征分析">选择指定特征分析</a></li>
            <li><a href="#结合分组方法与聚合函数分析">结合分组方法与聚合函数分析</a></li>
          </ul>
        </li>
        <li><a href="#groupbyapply">GroupBy.apply</a></li>
        <li><a href="#groupbyagg">GroupBy.agg</a></li>
        <li><a href="#groupbytransform">GroupBy.transform</a></li>
      </ul>
    </li>
    <li><a href="#德国能源数据时间序列分析">德国能源数据时间序列分析</a>
      <ul>
        <li><a href="#数据源-2">数据源</a></li>
        <li><a href="#基于时间索引筛选数据">基于时间索引筛选数据</a></li>
        <li><a href="#时间数据基本操作">时间数据基本操作</a></li>
        <li><a href="#周期性分析">周期性分析</a>
          <ul>
            <li><a href="#重采样分析周期性">重采样分析周期性</a></li>
            <li><a href="#数据差分分析周期性">数据差分分析周期性</a></li>
          </ul>
        </li>
        <li><a href="#滚动窗口">滚动窗口</a></li>
      </ul>
    </li>
    <li><a href="#k-means-clustering-algorithm">K-means clustering algorithm</a>
      <ul>
        <li><a href="#python实现">Python实现</a>
          <ul>
            <li><a href="#iterrows-遍历方式实现">iterrows 遍历方式实现</a></li>
            <li><a href="#apply-遍历方式实现">apply 遍历方式实现</a></li>
            <li><a href="#矩阵运算方式实现">矩阵运算方式实现</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#logistic-regression">Logistic regression</a>
      <ul>
        <li><a href="#线性回归">线性回归</a></li>
        <li><a href="#sigmoid">sigmoid</a></li>
        <li><a href="#逻辑回归公式">逻辑回归公式</a></li>
        <li><a href="#损失函数">损失函数</a></li>
        <li><a href="#梯度下降">梯度下降</a></li>
        <li><a href="#伪代码描述">伪代码描述</a></li>
        <li><a href="#python实现-1">Python实现</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><p>本文就『Lending Club贷款数据转换与融合』、『行星数据分组与聚合』以及『德国能源数据时间序列分析』等案例对Pandas中的部分分析方法以及机器学习中部分算法进行总结。</p>
<h2 id="lending-club贷款数据转换与融合">Lending Club贷款数据转换与融合</h2>
<p>　　该案例完整Jupyter Notebook可参考<a
  href="http://cookdata.cn/note/view_static_note/5acc2adb881ca8e68cfbb1cd1347d28d/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreffer"
  
  
  
  
>Lending Club贷款数据转换与融合</a>。</p>
<h3 id="数据源">数据源</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">user = pd.read_csv(&#34;./input/user.csv&#34;)
</span></span><span class="line"><span class="cl">loan = pd.read_csv(&#34;./input/loan.csv&#34;)
</span></span><span class="line"><span class="cl">history = pd.read_csv(&#34;./input/history.csv&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="随机采样sample">随机采样(sample)</h3>
<p>　　随机查看贷款交易数据中的5行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">loan.sample(n=5)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　随机查看贷款交易数据中的1%。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">loan.sample(frac=0.01)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　sample默认的是不放回采样（每个样本只可能出现一次），可以调整replace参数为True改为有放回采样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">loan.sample(n=10,replace=True)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　若希望重复调用某次采样的结果，可以设定random_state参数为同一个数来实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">loan.sample(n=5,random_state=42)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　除了行采样，sample也可以实现列采样，只需要调整axis参数为1即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">loan.sample(n=3,axis=1)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="数据融合mergejoin">数据融合(merge,join)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_user = user.loc[[1,3,5,7,8]]
</span></span><span class="line"><span class="cl">test_loan = loan[loan.user.isin([2,3,4,5,6,7])]
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　merge和join作为Pandas中常用的数据融合方法，目的都是将两个数据表通过共同变量进行连接。</p>
<h4 id="merge">merge</h4>
<p>　　merge参数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">left.merge(right, how=&#39;inner&#39;, on=None, 
</span></span><span class="line"><span class="cl">		left_on=None, right_on=None, 
</span></span><span class="line"><span class="cl">		left_index=False, right_index=False, 
</span></span><span class="line"><span class="cl">		sort=False, suffixes=(&#39;_x&#39;, &#39;_y&#39;), indicator=False)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　left和right分别指代要进行连接的两个数据框。<br>
　　on, left_on, right_on, 用来指定连接的变量。若这一变量在两个数据框中命名相同，直接使用on指定即可，否则通过left_on和right_on分别指定左表变量名和右表变量名。<br>
　　若需要基于数据框的索引进行连接，则要通过设定left_index和right_index的参数为True来实现。<br>
　　how为连接方式，有&rsquo;inner&rsquo;, &rsquo;left&rsquo;, &lsquo;right&rsquo;, &lsquo;outer&rsquo;四种。</p>
<p>　　基于用户信息数据的&rsquo;user_id&rsquo;变量和贷款交易数据的&rsquo;user&rsquo;变量进行内连接(inner)。这种方式下，只有所选定列在左表与右表能匹配的行会被保留。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_user.merge(test_loan,how=&#34;inner&#34;,
</span></span><span class="line"><span class="cl">				left_on=&#34;user_id&#34;,right_on=&#34;user&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　基于用户信息数据的&rsquo;user_id&rsquo;变量和贷款交易数据的&rsquo;user&rsquo;变量进行左连接(left)。这种方式下，左表所有行都被保留，不能匹配的部分用缺失值填充。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_user.merge(test_loan,how=&#34;left&#34;,
</span></span><span class="line"><span class="cl">				left_on=&#34;user_id&#34;,right_on=&#34;user&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　基于用户信息数据的&rsquo;user_id&rsquo;变量和贷款交易数据的&rsquo;user&rsquo;变量进行右连接(right)。这种方式下，右表所有行都被保留，不能匹配的部分用缺失值填充。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_user.merge(test_loan,how=&#34;right&#34;,
</span></span><span class="line"><span class="cl">				left_on=&#34;user_id&#34;,right_on=&#34;user&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　基于用户信息数据的&rsquo;user_id&rsquo;变量和贷款交易数据的&rsquo;user&rsquo;变量进行外连接(outer)。这种方式下，左表和右表所有行都会被保留，不能匹配的部分用缺失值填充。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_user.merge(test_loan,how=&#34;outer&#34;,
</span></span><span class="line"><span class="cl">				left_on=&#34;user_id&#34;,right_on=&#34;user&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　merge中的indicator参数能很好地找到返回结果的来源,设定indicator参数为Ture后，返回结果中多了一列&quot;_merge&quot;，取值有&quot;both&quot;, &ldquo;left_only&rdquo;, &ldquo;right_only&quot;三种。分别代表左右表匹配成功，左表有而右表没有，右表有而左表没有三种情况。</p>
<p>$$
\begin{array}{c|c|c}
&amp; .. &amp; _merge \
\hline
0 &amp; .. &amp; both \
\hline
1 &amp; .. &amp; left_only \
\hline
2 &amp; .. &amp; right_only
\end{array}
$$</p>
<p>　　当左表与右表中变量同名时，我们可以通过suffixes参数为左表变量与右表变量附加不同字段，便于后续区分。</p>
<p>$$
\begin{array}{c|c|c|c|c|c|c|c}
&amp; user &amp; term_l &amp; grade_l &amp; .. &amp; term_r &amp; grade_r &amp; .. \
\hline
0 &amp; 6 &amp; 60 months &amp; .. &amp; .. &amp; 60 months &amp; .. &amp; .. \
\hline
.. &amp; .. &amp; .. &amp; .. &amp; .. &amp; .. &amp; .. &amp; ..
\end{array}
$$</p>
<h4 id="join">join</h4>
<p>　　join参数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">left.join(right, on=None, how=&#39;left&#39;,
</span></span><span class="line"><span class="cl">		lsuffix=&#39;&#39;, rsuffix=&#39;&#39;, sort=False)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　事实上，join就是merge的简化版本，所有join能实现的操作，都可以使用merge实现。</p>
<ul>
<li>使用join时，右表只能基于索引进行连接；</li>
<li>通过on参数，可以指定左表进行连接的变量（可以是索引也可以是任意列）。</li>
</ul>
<p>　　merge和join中还有一个参数sort，指定为True会让返回的结果按连接变量进行升序排列。</p>
<h3 id="排序sort_indexsort_values">排序(sort_index,sort_values)</h3>
<p>　　Pandas中的sort_index和sort_values也可以对DataFrame进行排序，sort_index是按照索引进行排序，sort_values是按照指定变量排序。<br>
　　例如想将用户历史数据按账户平均存款排序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">history.sort_values(by=&#39;avg_cur_bal&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　若要降序排列，可以指定ascending参数为False。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">history.sort_values(by=&#39;avg_cur_bal&#39;,
</span></span><span class="line"><span class="cl">					ascending=False)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　也可以指定对缺失值的排序方式，默认缺失值将排在最后，可以设定na_position为first将缺失值排在最前面。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">history.sort_values(by=&#39;avg_cur_bal&#39;,
</span></span><span class="line"><span class="cl">					na_position=&#39;first&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="离散化cutqcut">离散化(cut,qcut)</h3>
<h4 id="cut">cut</h4>
<p>　　使用cut函数按照指定的分割点对数据进行划分。<br>
　　通过设定bin参数设定了分割点，将数据按照中位数进行了划分。同时设定了参数labels，使用这个参数可以方便地为新的划分区间命名。<br>
　　<strong>左开右闭区间</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">annual_inc = pd.cut(combine.annual_inc,
</span></span><span class="line"><span class="cl">					bins=[np.min(combine.annual_inc)-1,
</span></span><span class="line"><span class="cl">                    	np.percentile(combine.annual_inc,50),
</span></span><span class="line"><span class="cl">                    	np.max(combine.annual_inc)+1],
</span></span><span class="line"><span class="cl">					labels=[&#39;low&#39;,&#39;high&#39;])
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　cut也可以直接指定划分份数，将数据等距划分。<br>
　　例如，将数据等距分为五份：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pd.cut(combine.annual_inc,5)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　理论上，数据应被等距分为了五份，每一个区间的长度都相同，但我们计算可以发现，第一个区间的长度为113364，而其他几个区间的长度都为112800。这并不是cut分割错误，只是为了包含最小值或最大值，<strong>cut的左右端会拓展0.1%</strong>。</p>
<h4 id="qcut">qcut</h4>
<p>　　Pandas中与cut相似的另一个函数是qcut，它将按照每个区间中频数相同的原则进行划分,当我们指定划分份数后，就会用相应的分位数进行划分。例如，当我们使用qcut将数据分为两份时，分割点就是中位数，四份时分割点就是四分位数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pd.qcut(combine.annual_inc,2)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="值替换replacemap">值替换(replace,map)</h3>
<p>　　认为状态为&quot;Charged Off&rdquo;,&ldquo;In Grace Period&rdquo;, &ldquo;Late (31-120 days)&ldquo;的贷款有违约风险，视为不良贷款，将其值标记为1，其他贷款标记为0。<br>
　　使用replace进行值替换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">combine[&#39;loan_status&#39;].replace(
</span></span><span class="line"><span class="cl">	to_replace=[&#39;Fully Paid&#39;,&#39;Current&#39;,&#39;Charged Off&#39;,&#39;In Grace Period&#39;,&#39;Late (31-120 days)&#39;],
</span></span><span class="line"><span class="cl">    value=[0,0,1,1,1],
</span></span><span class="line"><span class="cl">    inplace=True)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　除了将需要替换的值与替换的新值分别用列表输入外，也可以使用字典进行指定。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_loan.replace(to_replace={&#39;loan_status&#39;:{&#39;Fully Paid&#39;:0,&#39;Charged Off&#39;:0,&#39;In Grace Period&#39;:1}})
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　也可以同时指定不同变量的不同值替换为相同新值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_loan.replace(to_replace={&#39;loan_status&#39;:&#39;Fully Paid&#39;,&#39;grade&#39;:&#39;A&#39;},value=&#39;Good&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　也可以指定正则表达式进行替换，这时需要设定参数regex为True，代表to_replace部分输入的是正则表达式。如查找所有以C开头的字段并替换为Bad。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_loan.replace(to_replace=&#39;C+.*$&#39;, value=&#39;Bad&#39;, regex=True)
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="map">map</h4>
<p>　　在Pandas中，如果只是针对某一个Series进行数值替代，我们也可以使用map方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">test_loan[&#39;loan_status&#39;].map({&#39;Fully Paid&#39;:0,&#39;Charged Off&#39;:0,&#39;In Grace Period&#39;:1})
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　这同样实现了将贷款状态进行替换的效果，但map不能像replace一样直接对DataFrame进行操作。不过map不仅仅可以像上面一样输入字典作为参数，也可以直接输入一个函数进行映射。<br>
　　例如，将数据中利率低于12%的映射为&rsquo;Low&rsquo;，高于12%的映射为&rsquo;High&rsquo;。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def f(x):
</span></span><span class="line"><span class="cl">    if x &lt; 12:
</span></span><span class="line"><span class="cl">        return &#39;Low&#39;
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        return &#39;High&#39;
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">combine[&#39;int_rate&#39;].map(f)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="哑变量处理get_dummies">哑变量处理(get_dummies)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cat_vars=[&#39;term&#39;,&#39;grade&#39;,&#39;emp_length&#39;,&#39;annual_inc&#39;,&#39;home_ownership&#39;,&#39;verification_status&#39;]
</span></span><span class="line"><span class="cl">for var in cat_vars:
</span></span><span class="line"><span class="cl">    cat_list = pd.get_dummies(combine[var], prefix=var, drop_first=True)
</span></span><span class="line"><span class="cl">    combine=combine.join(cat_list)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　get_dummies函数中使用了两个参数。prefix可以为新生成的哑变量添加前缀，这方便我们识别新生成的变量是从原来哪一个变量中得来的。drop_first设置为True将删去所获得哑变量的第一个，这是因为在建模中，有k类的分类变量只需要k-1个变量就可以将其描述，如果使用k个变量则会出现完全共线性的问题。<br>
　　此外，在这里选择了使用join而不是merge，这是因为get_dummies返回的结果与原始数据有相同的索引，使用join直接基于索引进行连接更简洁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> pd.get_dummies(combine[&#39;grade&#39;], prefix=&#39;grade&#39;,drop_first=True)[:5]
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c}
&amp;grade_B&amp;	grade_C&amp;	grade_D&amp;	grade_E&amp;	grade_F&amp;	grade_G\
\hline
0&amp;	0&amp;	0&amp;	1&amp;	0&amp;	0&amp;	0&amp; \
\hline
1&amp;	0&amp;	1&amp;	0&amp;	0&amp;	0&amp;	0&amp; \
\hline
2&amp;	1&amp;	0&amp;	0&amp;	0&amp;	0&amp;	0&amp; \
\hline
3&amp;	0&amp;	0&amp;	0&amp;	0&amp;	0&amp;	0&amp;\
\hline
4&amp;	0&amp;	1&amp;	0&amp;	0&amp;	0&amp;	0&amp;
\end{array}
$$</p>
<p>　　如果使用merge：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">combine=combine.merge(cat_list,left_index=True,right_index=True)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="添加常数项列concat">添加常数项列(concat)</h3>
<p>　　在回归分析中，我们往往还需要为自变量添加常数项列，值全为1。<br>
　　首先创建一个长度为X的行数，值全为1的列表。再将其转化为Series，并命名&quot;const&rdquo;。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">const = pd.Series([1] * combine.shape[0],name=&#34;const&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　重设X索引，使用concat对数据进行合并，并指定方向为列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">X.reset_index(drop=True,inplace=True)
</span></span><span class="line"><span class="cl">X = pd.concat([const,X],axis=1)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　这里之所以要先重新设置X的索引，是因为concat是基于索引进行拼接的。这么看来，对于列的拼接其实直接使用join就可以了，不过目前join只能作为DataFrame的方法，想拼接DataFrame和Series就必须把DataFrame写在前面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">X.join(const)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　此外，concat更常用的是进行行的连接。concat参数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  pandas.concat(objs, axis=0, join=&#39;outer&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　objs: Series,DataFrame等构成的list<br>
　　axis: 合并连接的方向，0是行，1是列<br>
　　join：连接方式，&ldquo;inner&quot;或者&quot;outer&rdquo;</p>
<p>　　可以看到，concat的对象必须是一个list。</p>
<p>　　创建两个dataframe:df1,df2。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">df1 = pd.DataFrame([[&#39;a&#39;,&#39;a&#39;, 1], [&#39;b&#39;,&#39;b&#39;, 2]],columns=[&#39;letter&#39;,&#39;letter1&#39;,&#39;number&#39;])
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c}
&amp; letter &amp; letter1	&amp; number\
\hline
0	&amp; a	&amp; a	&amp; 1\
\hline
1	&amp; b	&amp; b	&amp; 2
\end{array}
$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">df2 = pd.DataFrame([[&#39;c&#39;,&#39;c&#39;, 3], [&#39;d&#39;,&#39;d&#39;, 4]],columns=[&#39;letter&#39;,&#39;letter2&#39;,&#39;number&#39;])
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c}
&amp; letter &amp; letter1	&amp; number\
\hline
0	&amp; c	&amp; c	&amp; 3\
\hline
1	&amp; d	&amp; d	&amp; 4
\end{array}
$$</p>
<p>　　使用inner方式进行连接，只有能够匹配的变量才会保留。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pd.concat([df1,df2],axis=0,join=&#39;inner&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c}
&amp; letter &amp; number \
\hline
0 &amp;	a &amp;	1 \
\hline
1 &amp;	b &amp;	2 \
\hline
0 &amp;	c &amp;	3 \
\hline
1 &amp;	d &amp;	4
\end{array}
$$
　　使用outer方式进行连接，所有变量都会保留，不能匹配的部分用缺失值填充。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pd.concat([df1,df2],axis=0,join=&#39;outer&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c}
&amp; letter &amp;	letter1 &amp; letter2 &amp;	number \
\hline
0 &amp;	a&amp;	a&amp;	NaN&amp;	1 \
\hline
1&amp;	b&amp;	b&amp;	NaN&amp;	2 \
\hline
0&amp;	c&amp;	NaN&amp;	c&amp;	3 \
\hline
1&amp;	d&amp;	NaN&amp;d	4&amp;
\end{array}
$$</p>
<p>　　ignore_index参数为Ture将忽略原来的索引，从0开始重建索引。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pd.concat([df1,df2],ignore_index=True)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　通过key参数可以建立多层索引，方便识别数据来自于哪个数据源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pd.concat([df1,df2],keys=[&#39;df1&#39;, &#39;df2&#39;])
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c|c}
&amp; &amp; letter &amp; letter1 &amp; letter2&amp; number \
\hline
df1 &amp; 0 &amp; a &amp; a &amp; NaN &amp; 1 \
&amp; 1 &amp; b &amp; b &amp; NaN &amp; 2 \
\hline
df2 &amp; 0 &amp; c &amp; NaN &amp; c &amp; 3 \
&amp; 1 &amp; d &amp; NaN &amp; d &amp; 4 \
\end{array}
$$</p>
<h2 id="行星数据分组与聚合">行星数据分组与聚合</h2>
<p>　　该案例完整Jupyter Notebook可参考<a
  href="http://cookdata.cn/note/view_static_note/7b30c741facfb06d83bc37ae3a7fa8a3/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreffer"
  
  
  
  
>行星数据分组与聚合</a>。</p>
<h3 id="数据源-1">数据源</h3>
<p>　　行星数据集记录了2014年之前发现的行星的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">planets = pd.read_csv(&#34;./input/planets.csv&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c|c|c}
&amp; method&amp;number&amp;orbital_period&amp;mass&amp;distance&amp;year \
\hline
0&amp;	Radial Velocity	&amp;1&amp;	269.300	&amp;7.10	&amp;77.40	&amp;2006 \
\hline
1&amp;	Radial Velocity	&amp;1&amp;	874.774	&amp;2.21	&amp;56.95	&amp;2008 \
\hline
2&amp;	Radial Velocity	&amp;1&amp;	763.000	&amp;2.60	&amp;19.84	&amp;2011 \
\hline
3&amp;	Radial Velocity	&amp;1&amp;	326.030	&amp;19.40	&amp;110.62	&amp;2007 \
\hline
4&amp;	Radial Velocity	&amp;1&amp;	516.220	&amp;10.50	&amp;119.47	&amp;2009
\end{array}
$$</p>
<h3 id="数据分组">数据分组</h3>
<h4 id="通过特征分组">通过特征分组</h4>
<p>　　groupby可以指定某一个特征或指定某一组特征进行分组。<br>
　　例如按method特征对数据进行分组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped = planets.groupby(&#39;method&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f1d00504a58&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　groupby还能通过指定一个与目标数据等长的array、list或Series进行分组。<br>
　　例如，行星数据集共有1035条记录，生成一个长度为1035，前500都为0，后535都为1的array。<br>
　　使用repeat，输入中第一部分指定了值，第二部分指定对应值的重复次数。我们将生成结果记为a。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a = np.repeat([0,1], [500, 535])
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　以其对原数据进行分组，并计算各特征的均值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">planets.groupby(a).mean()
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c|c}
&amp;number&amp;orbital_period&amp;mass&amp;distance&amp;year\
\hline
0&amp;	1.644000&amp;	1450.908401&amp;	2.580901&amp;	97.615625&amp;	2007.916000&amp; \
\hline
1&amp;	1.917757&amp;	2526.729858&amp;	2.800112&amp;	507.660000&amp;	2010.149533&amp;
\end{array}
$$</p>
<h4 id="通过函数分组">通过函数分组</h4>
<p>　　也可以通过函数进行分组。<br>
　　例如，想将数据按发现年份在2000年前和2000年后进行分组。使用set_index设定year变量为数据的新索引，然后定义一个函数test，当数据小于2000时返回&rsquo;Before 2000&rsquo;，大于等于2000时返回&rsquo;After 2000&rsquo;，最后通过自定义函数test进行分组，并求各组各变量均值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">new = planets.set_index(&#39;year&#39;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def test(x):
</span></span><span class="line"><span class="cl">    if x&lt;2000:
</span></span><span class="line"><span class="cl">        return &#39;Before 2000&#39;
</span></span><span class="line"><span class="cl">    else:
</span></span><span class="line"><span class="cl">        return &#39;After 2000&#39;
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">new.groupby(test).mean()
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c}
&amp;	number&amp;	orbital_period&amp;	mass&amp;	distance\
\hline
After 2000&amp;	1.780658&amp;	2058.025770&amp;	2.615027&amp;	272.918742&amp;\
\hline
Before 2000&amp;	1.937500&amp;	349.672379&amp;	3.071469&amp;	26.354483&amp;
\end{array}
$$
　　函数的输入是数据的索引列。以上代码相当于这样两步操作：<br>
　　1. 对目标数据索引的每一个元素执行相应函数；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">group_index = new.index.map(test)
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Index([&#39;After 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;,
</span></span><span class="line"><span class="cl">       &#39;After 2000&#39;, &#39;After 2000&#39;, &#39;Before 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;,
</span></span><span class="line"><span class="cl">       ...
</span></span><span class="line"><span class="cl">       &#39;After 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;,
</span></span><span class="line"><span class="cl">       &#39;After 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;, &#39;After 2000&#39;],
</span></span><span class="line"><span class="cl">      dtype=&#39;object&#39;, name=&#39;year&#39;, length=1035)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　2. 以这一个新变量group_index进行分组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">new.groupby(group_index).mean()
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c}
&amp;	number&amp;	orbital_period&amp;	mass&amp;	distance\
\hline
year &amp; &amp; &amp; &amp; \
\hline
After 2000&amp;	1.780658&amp;	2058.025770&amp;	2.615027&amp;	272.918742\
\hline
Before 2000&amp;	1.937500&amp;	349.672379&amp;	3.071469&amp;	26.354483
\end{array}
$$</p>
<h3 id="groupby对象的基本操作">GroupBy对象的基本操作</h3>
<h4 id="对分组进行迭代">对分组进行迭代</h4>
<p>　　groupby返回的结果是一个GroupBy类型的对象，可以使用循环查看其内部结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pd.set_option(&#39;expand_frame_repr&#39;,False)
</span></span><span class="line"><span class="cl">for (name,group) in grouped:
</span></span><span class="line"><span class="cl">    print(name)
</span></span><span class="line"><span class="cl">    print(group.head(n=2),&#39;\n&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　GroupBy类型的对象是由各组组名与其对应的分组数据构成。这里只依据method一个特征进行了分组，若基于多个特征进行分组，则返回的GroupBy的组名会是一个多元元组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (name,group) in planets.groupby([&#39;method&#39;,&#39;year&#39;]):
</span></span><span class="line"><span class="cl">    print(name)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　GroupBy内部是由一个个DataFrame组成，可以在循环中对每组数据进行操作。<br>
　　例如，对每组数据使用shape。为了使输出更美观，我们使用format指定了输出的字符串格式，第一个{0:30s}匹配format中第一个字符串method，并指定字符串长度为30；第二个{1}匹配format中第二个字符串group.shape。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (method, group) in planets.groupby(&#39;method&#39;):
</span></span><span class="line"><span class="cl">    print(&#34;{0:30s} shape={1}&#34;.format(method, group.shape))
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Astrometry                     shape=(2, 6)
</span></span><span class="line"><span class="cl">Eclipse Timing Variations      shape=(9, 6)
</span></span><span class="line"><span class="cl">Imaging                        shape=(38, 6)
</span></span><span class="line"><span class="cl">Microlensing                   shape=(23, 6)
</span></span><span class="line"><span class="cl">Orbital Brightness Modulation  shape=(3, 6)
</span></span><span class="line"><span class="cl">Pulsar Timing                  shape=(5, 6)
</span></span><span class="line"><span class="cl">Pulsation Timing Variations    shape=(1, 6)
</span></span><span class="line"><span class="cl">Radial Velocity                shape=(553, 6)
</span></span><span class="line"><span class="cl">Transit                        shape=(397, 6)
</span></span><span class="line"><span class="cl">Transit Timing Variations      shape=(4, 6)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　也有一些可以直接对GroupBy使用的方法，例如size方法可以查看每个分组的数据量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.size()
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">method
</span></span><span class="line"><span class="cl">Astrometry                         2
</span></span><span class="line"><span class="cl">Eclipse Timing Variations          9
</span></span><span class="line"><span class="cl">Imaging                           38
</span></span><span class="line"><span class="cl">Microlensing                      23
</span></span><span class="line"><span class="cl">Orbital Brightness Modulation      3
</span></span><span class="line"><span class="cl">Pulsar Timing                      5
</span></span><span class="line"><span class="cl">Pulsation Timing Variations        1
</span></span><span class="line"><span class="cl">Radial Velocity                  553
</span></span><span class="line"><span class="cl">Transit                          397
</span></span><span class="line"><span class="cl">Transit Timing Variations          4
</span></span><span class="line"><span class="cl">dtype: int64
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="选择指定特征分析">选择指定特征分析</h4>
<p>　　针对GroupBy类型的对象，我们可以直接选取出需要的列。例如，取出year特征。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped[&#39;year&#39;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　这仍然是一个GroupBy类型的对象，但和之前的结果相比，这是一个SeriesGroupBy，而之前的是一个DataFrameGroupBy。<br>
　　对于这种类型，可以直接使用一些聚合函数（如sum、mean、max、min&hellip;）。例如，查看不同方法发现的行星与地球距离的中位数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">planets.groupby(&#39;method&#39;)[&#39;distance&#39;].median()
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　也可以直接使用describe。例如查看不同方法发现行星的时间情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped[&#39;year&#39;].describe()
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c|c}
&amp; count &amp; mean &amp; std &amp; min &amp; 25% &amp; 50% &amp; 75% &amp; max \
\hline
method\
\hline
Astrometry	&amp;2.0&amp;2011.500000&amp;2.121320&amp;2010.0&amp;2010.75&amp;2011.5&amp;2012.25&amp;2013.0\
\hline
&hellip;
\end{array}
$$</p>
<h4 id="结合分组方法与聚合函数分析">结合分组方法与聚合函数分析</h4>
<p>　　首先将年份按每10年进行划分。通过//将年份整除10（向下取整），再乘以10，可以将年份变换为对应年代。再使用astype将类型转换为字符串并加上&rsquo;s&rsquo;代表对应年代。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">decade = 10 * (planets[&#39;year&#39;] // 10)
</span></span><span class="line"><span class="cl">decade = decade.astype(str) + &#39;s&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　按发现行星的方法和发现的年代进行分组，并统计相应分组下发现的行星的总数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">planets.groupby([&#39;method&#39;, decade])[&#39;number&#39;].sum()
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">method						year 
</span></span><span class="line"><span class="cl">Astrometry					2010s      2
</span></span><span class="line"><span class="cl">Eclipse Timing Variations	2000s      5
</span></span><span class="line"><span class="cl">							2010s     10
</span></span><span class="line"><span class="cl">Imaging						2000s     29
</span></span><span class="line"><span class="cl"> 							2010s     21
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　使用unstack将按层次化索引拆开为新的列索引。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">planets.groupby([&#39;method&#39;, decade])[&#39;number&#39;].sum().unstack()
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c}
year&amp;1980s&amp;1990s&amp;2000s&amp;2010s \
\hline
method \
\hline
Astrometry&amp;NaN&amp;NaN&amp;NaN&amp;2.0 \
\hline
Eclipse Timing Variations&amp;NaN&amp;NaN&amp;5.0&amp;10.0\
\hline
&hellip;
\end{array}
$$</p>
<h3 id="groupbyapply">GroupBy.apply</h3>
<p>　　apply方法能够分别对每一份分组数据进行对应的函数操作，再合并成一个数据表。因此，apply中使用的函数必须是以DataFrame作为输入的，而且每一个apply语句只能传入一个函数。<br>
　　例如：使用apply计算不同方法发现的行星在各特征上的极差(最大值与最小值之差)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.apply(lambda x: x.max() - x.min())
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c|c}
&amp;number&amp;orbital_period&amp;mass&amp;distance&amp;year\
\hline
method \
\hline
Astrometry&amp;	0.0&amp;769.640000&amp;NaN&amp;5.79	&amp;3.0 \
\hline
Eclipse Timing Variations&amp;1.0&amp;8303.750000&amp;1.8500&amp;369.28	&amp;4.0 \
\hline
&hellip;
\end{array}
$$</p>
<p>　　此例中，每一组数据返回了一个Series。apply应用的函数也可以只返回一个标量，例如计算每种方法发现的行星中和地球距离的最大值与轨道周期的最大值之比。
<em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">method
</span></span><span class="line"><span class="cl">Astrometry                         0.020443
</span></span><span class="line"><span class="cl">Eclipse Timing Variations          0.048924
</span></span><span class="line"><span class="cl">Imaging                            0.000226
</span></span><span class="line"><span class="cl">Microlensing                       1.513725
</span></span><span class="line"><span class="cl">Orbital Brightness Modulation    763.789269
</span></span><span class="line"><span class="cl">Pulsar Timing                      0.032854
</span></span><span class="line"><span class="cl">Pulsation Timing Variations             NaN
</span></span><span class="line"><span class="cl">Radial Velocity                    0.020418
</span></span><span class="line"><span class="cl">Transit                           25.633248
</span></span><span class="line"><span class="cl">Transit Timing Variations         13.243750
</span></span><span class="line"><span class="cl">dtype: float64
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　apply应用的函数也可以返回一个DataFrame。例如分组中心化数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.apply(lambda x: x-x.mean())
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c|c|c}
&amp;distance&amp;	mass&amp;	method&amp;	number&amp;	orbital_period&amp;	year\
\hline
0&amp;	25.799792&amp;	4.469301&amp;	NaN&amp;	-0.721519&amp;	-554.05468&amp;	-1.518987\
\hline
1&amp;	5.349792&amp;	-0.420699&amp;	NaN&amp;	-0.721519&amp;	51.41932&amp;	0.481013\
\hline
&hellip;
\end{array}
$$</p>
<p>　　当apply中运用的函数除了输入的DataFrame外还有其他参数时，直接在apply中进行赋值即可。例如查看按method分组后各组数据的前两行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def func1(x,n):
</span></span><span class="line"><span class="cl">    return(x.head(n))
</span></span><span class="line"><span class="cl">grouped.apply(func1,n=2)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　apply的运行实际过程有分开运算、结果合并两步，因此，在数据量较大时，apply的运行速度会比可以实现同样操作的其他方法要慢。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%timeit grouped.apply(np.mean)
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>16.1 ms ± 50.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%timeit grouped.mean()
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>624 µs ± 337 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)</em></p>
<p>　　总结来看，apply方法只需要传入的函数的输入为DataFrame即可，函数的输出可以是标量、Series或DataFrame。但必须以DataFrame为输入就会导致当我们想对不同特征分别进行操作时比较麻烦。例如，分别计算各种方法发现的行星的距离的均值和发现的数量之和。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def func2(df):
</span></span><span class="line"><span class="cl">    mean_distance = np.mean(df[&#39;distance&#39;])
</span></span><span class="line"><span class="cl">    sum_number = np.sum(df[&#39;number&#39;])
</span></span><span class="line"><span class="cl">    return(pd.Series({&#39;mean_distance&#39;:mean_distance,&#39;sum_number&#39;:sum_number}))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">grouped.apply(func2) 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="groupbyagg">GroupBy.agg</h3>
<p>　　同样，分别计算各种方法发现的行星的距离的均值和发现的数量之和。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.agg({&#39;distance&#39;:&#39;mean&#39;,&#39;number&#39;:&#39;sum&#39;})
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　这里使用“变量名:函数名”的形式向agg传入一个字典。agg方法可以针对某个特征同时执行多个函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.agg({&#39;distance&#39;:[&#39;min&#39;,&#39;max&#39;,&#39;mean&#39;,&#39;median&#39;],&#39;number&#39;:&#39;sum&#39;})
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　agg方法中同样可以使用自定义函数，例如求极差：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.agg(lambda x: x.max()-x.min())
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　需要注意，尽管这里使用agg和apply获得了相同的结果，但是，在apply中是对每一组数据整个DataFrame进行一次运算，而在agg中将对每一组数据中的每一个特征进行运算。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def test2(x):
</span></span><span class="line"><span class="cl">    return(x.shape)
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.apply(test2)
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">method
</span></span><span class="line"><span class="cl">Astrometry                         (2, 6)
</span></span><span class="line"><span class="cl">Eclipse Timing Variations          (9, 6)
</span></span><span class="line"><span class="cl">Imaging                           (38, 6)
</span></span><span class="line"><span class="cl">Microlensing                      (23, 6)
</span></span><span class="line"><span class="cl">Orbital Brightness Modulation      (3, 6)
</span></span><span class="line"><span class="cl">Pulsar Timing                      (5, 6)
</span></span><span class="line"><span class="cl">Pulsation Timing Variations        (1, 6)
</span></span><span class="line"><span class="cl">Radial Velocity                  (553, 6)
</span></span><span class="line"><span class="cl">Transit                          (397, 6)
</span></span><span class="line"><span class="cl">Transit Timing Variations          (4, 6)
</span></span><span class="line"><span class="cl">dtype: object
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.agg(test2)
</span></span></code></pre></td></tr></table>
</div>
</div><p>$$
\begin{array}{c|c|c|c|c|c|c}
&amp; number&amp;	orbital_period	&amp; mass &amp; distance &amp;	year \
\hline
method \
\hline
Astrometry&amp;	(2,)&amp;	(2,)&amp;	(2,)&amp;	(2,)&amp;	(2,)\
\hline
Eclipse Timing Variations&amp;	(9,)&amp;	(9,)&amp;	(9,)&amp;	(9,)&amp;	(9,)\
\hline
&hellip;
\end{array}
$$
　　可以看到，apply返回的是每一组数据的维度，而agg返回的是每组数据下，每一个特征对应的数据的维度。因此，我们可以将agg的操作分为3步：<br>
　　1. 对每组数据中的每一列执行函数;<br>
　　2. 将每一列返回结果合并;<br>
　　3. 将每一组数据返回结果合并</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%timeit grouped.apply(lambda x: x.max()-x.min())
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>32.2 ms ± 28.9 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">%timeit grouped.agg(lambda x:x.max()-x.min())
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>19.6 ms ± 7.73 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</em></p>
<p>　　因此，尽管相比于apply，agg可以从更细的维度进行数据处理，但也意味着更多的运算消耗。同时，agg方法对使用的函数的返回也有一定要求：对每一个特征，函数只能返回一个标量。例如，使用apply进行中心化的操作无法使用agg完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.agg(lambda x: x-x.mean())
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ValueError: Shape of passed values is (6, 10), indices imply (5, 10)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="groupbytransform">GroupBy.transform</h3>
<p>　　transform方法中传入的函数只能返回两种结果，可以广播的标量值或者与分组数据维度相同的数据。<br>
　　对分组数据求均值，然后把这个均值赋值给整个组（可广播的标量值）。</p>
<p>$$
\begin{array}{c|c|c|c|c|c}
&amp; number&amp;	orbital_period&amp;	mass&amp;	distance&amp;	year \
\hline
0&amp;	1.721519&amp;	823.35468&amp;	2.630699&amp;	51.600208&amp;	2007.518987\
\hline
1&amp;	1.721519&amp;	823.35468&amp;	2.630699&amp;	51.600208&amp;	2007.518987\
\hline
&hellip;
\end{array}
$$</p>
<p>　　使用<code>transform</code>实现分组数据标准化($\dfrac{x-\bar{x}}{s}$)(分组数据维度相同的数据):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grouped.transform(lambda x: (x - x.mean()) / x.std())
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　apply中自定义函数对每个分组数据单独进行处理，再将结果合并；整个DataFrame的函数输出可以是标量、Series或DataFrame；每个apply语句只能传入一个函数；<br>
　　agg可以通过字典方式指定特征进行不同的函数操作，每一特征的函数输出必须为标量；<br>
　　transform不可以通过字典方式指定特征进行不同的函数操作，但函数运算单位也是DataFrame的每一特征，每一特征的函数输出可以是标量或者Series，但标量会被广播。</p>
<h2 id="德国能源数据时间序列分析">德国能源数据时间序列分析</h2>
<p>　　该案例完整Jupyter Notebook可参考<a
  href="http://cookdata.cn/note/view_static_note/abdeedf821256e7ffacffe03f68e4cf2/"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreffer"
  
  
  
  
>德国能源数据时间序列分析</a>。</p>
<h3 id="数据源-2">数据源</h3>
<p>　　数据的字段及其说明如下：
$$
\begin{array}{c|c}
变量名称&amp;含义说明 \
\hline
Date&amp;日期 \
\hline
Consumption&amp;电力消耗 \
\hline
Wind&amp;风能发电量 \
\hline
Solar&amp;太阳能发电量
\end{array}
$$</p>
<p>　　使用dtypes查看数据类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.dtypes
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Date           datetime64[ns]
</span></span><span class="line"><span class="cl">Consumption           float64
</span></span><span class="line"><span class="cl">Wind                  float64
</span></span><span class="line"><span class="cl">Solar                 float64
</span></span><span class="line"><span class="cl">Wind+Solar            float64
</span></span><span class="line"><span class="cl">dtype: object
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　使用set_index将Date变量设定为索引。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.set_index(&#39;Date&#39;,inplace=True)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　也可以在数据导入时通过参数设置实现这些操作。设定index_col为0即以数据中第一列为索引，设定parse_dates为True，会把索引识别为时间数据类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd = pd.read_csv(&#39;./input/opsd_germany_daily.csv&#39;, index_col=0, parse_dates=True)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　查看此时索引格式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.index
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">DatetimeIndex([&#39;2006-01-01&#39;, &#39;2006-01-02&#39;, &#39;2006-01-03&#39;, &#39;2006-01-04&#39;,
</span></span><span class="line"><span class="cl">               &#39;2006-01-05&#39;, &#39;2006-01-06&#39;, &#39;2006-01-07&#39;, &#39;2006-01-08&#39;,
</span></span><span class="line"><span class="cl">               &#39;2006-01-09&#39;, &#39;2006-01-10&#39;,
</span></span><span class="line"><span class="cl">               ...
</span></span><span class="line"><span class="cl">               &#39;2017-12-22&#39;, &#39;2017-12-23&#39;, &#39;2017-12-24&#39;, &#39;2017-12-25&#39;,
</span></span><span class="line"><span class="cl">               &#39;2017-12-26&#39;, &#39;2017-12-27&#39;, &#39;2017-12-28&#39;, &#39;2017-12-29&#39;,
</span></span><span class="line"><span class="cl">               &#39;2017-12-30&#39;, &#39;2017-12-31&#39;],
</span></span><span class="line"><span class="cl">              dtype=&#39;datetime64[ns]&#39;, name=&#39;Date&#39;, length=4383, freq=None)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　可以使用asfreq进行指定。如果数据中缺失了某个时间，asfreq将自动为这些时间添加新行，并默认分配空值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd = opsd.asfreq(&#39;D&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">DatetimeIndex([&#39;2006-01-01&#39;, &#39;2006-01-02&#39;, &#39;2006-01-03&#39;, &#39;2006-01-04&#39;,
</span></span><span class="line"><span class="cl">               &#39;2006-01-05&#39;, &#39;2006-01-06&#39;, &#39;2006-01-07&#39;, &#39;2006-01-08&#39;,
</span></span><span class="line"><span class="cl">               &#39;2006-01-09&#39;, &#39;2006-01-10&#39;,
</span></span><span class="line"><span class="cl">               ...
</span></span><span class="line"><span class="cl">               &#39;2017-12-22&#39;, &#39;2017-12-23&#39;, &#39;2017-12-24&#39;, &#39;2017-12-25&#39;,
</span></span><span class="line"><span class="cl">               &#39;2017-12-26&#39;, &#39;2017-12-27&#39;, &#39;2017-12-28&#39;, &#39;2017-12-29&#39;,
</span></span><span class="line"><span class="cl">               &#39;2017-12-30&#39;, &#39;2017-12-31&#39;],
</span></span><span class="line"><span class="cl">              dtype=&#39;datetime64[ns]&#39;, name=&#39;Date&#39;, length=4383, freq=&#39;D&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="基于时间索引筛选数据">基于时间索引筛选数据</h3>
<p>　　对于时间数据索引，可以使用loc提取数据。例如，查找2017年8月10日的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.loc[&#39;2017-08-10&#39;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　也可以选择一段时间，例如2014年1月20日至2014年1月22日的数据。与使用loc的常规索引一样，切片将包含两个端点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.loc[&#39;2014-01-20&#39;:&#39;2014-01-22&#39;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　可以不具体到日，而仅仅指定对应的年和月，将返回当月的所有数据。例如，查找2017年1月份的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.loc[&#39;2017-01&#39;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　获取时间范围内的数据也可以使用truncate进行筛选。before将删去给定日期之前的数据，after将删去给定日期之后的数据。例如，筛选2017年1月份的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.truncate(before=&#39;2017-01-01&#39;,after=&#39;2017-01-31&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="时间数据基本操作">时间数据基本操作</h3>
<p>　　针对时间数据，可以使用year，month，weekday等多种方法获取对应时间的年份、月份和星期。<br>
　　首先使用index提取数据的索引。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsdtime = opsd.index
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">DatetimeIndex([&#39;2006-01-01&#39;, &#39;2006-01-02&#39;, &#39;2006-01-03&#39;, &#39;2006-01-04&#39;,
</span></span><span class="line"><span class="cl">               &#39;2006-01-05&#39;, &#39;2006-01-06&#39;, &#39;2006-01-07&#39;, &#39;2006-01-08&#39;,
</span></span><span class="line"><span class="cl">               &#39;2006-01-09&#39;, &#39;2006-01-10&#39;,
</span></span><span class="line"><span class="cl">               ...
</span></span><span class="line"><span class="cl">               &#39;2017-12-22&#39;, &#39;2017-12-23&#39;, &#39;2017-12-24&#39;, &#39;2017-12-25&#39;,
</span></span><span class="line"><span class="cl">               &#39;2017-12-26&#39;, &#39;2017-12-27&#39;, &#39;2017-12-28&#39;, &#39;2017-12-29&#39;,
</span></span><span class="line"><span class="cl">               &#39;2017-12-30&#39;, &#39;2017-12-31&#39;],
</span></span><span class="line"><span class="cl">              dtype=&#39;datetime64[ns]&#39;, name=&#39;Date&#39;, length=4383, freq=&#39;D&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　使用year提取每个数据对应的年份。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsdtime.year
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Int64Index([2006, 2006, 2006, 2006, 2006, 2006, 2006, 2006, 2006, 2006,
</span></span><span class="line"><span class="cl">            ...
</span></span><span class="line"><span class="cl">            2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017],
</span></span><span class="line"><span class="cl">           dtype=&#39;int64&#39;, name=&#39;Date&#39;, length=4383)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　使用month提取月份。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsdtime.month
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Int64Index([ 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
</span></span><span class="line"><span class="cl">            ...
</span></span><span class="line"><span class="cl">            12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
</span></span><span class="line"><span class="cl">           dtype=&#39;int64&#39;, name=&#39;Date&#39;, length=4383)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　month返回的是对应月份的数字，若想要获得月份的名字可以使用month_name。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsdtime.month_name()
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Index([&#39;January&#39;, &#39;January&#39;, &#39;January&#39;, &#39;January&#39;, &#39;January&#39;, &#39;January&#39;,
</span></span><span class="line"><span class="cl">       &#39;January&#39;, &#39;January&#39;, &#39;January&#39;, &#39;January&#39;,
</span></span><span class="line"><span class="cl">       ...
</span></span><span class="line"><span class="cl">       &#39;December&#39;, &#39;December&#39;, &#39;December&#39;, &#39;December&#39;, &#39;December&#39;, &#39;December&#39;,
</span></span><span class="line"><span class="cl">       &#39;December&#39;, &#39;December&#39;, &#39;December&#39;, &#39;December&#39;],
</span></span><span class="line"><span class="cl">      dtype=&#39;object&#39;, name=&#39;Date&#39;, length=4383)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　可以使用weekday和weekday_name（新版本API已修改为<code>day_name()</code>）查看日期是星期几。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsdtime.weekday
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Int64Index([6, 0, 1, 2, 3, 4, 5, 6, 0, 1,
</span></span><span class="line"><span class="cl">            ...
</span></span><span class="line"><span class="cl">            4, 5, 6, 0, 1, 2, 3, 4, 5, 6],
</span></span><span class="line"><span class="cl">           dtype=&#39;int64&#39;, name=&#39;Date&#39;, length=4383)
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsdtime.weekday_name
</span></span><span class="line"><span class="cl"># opsdtime.day_name()
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Index([&#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;,
</span></span><span class="line"><span class="cl">       &#39;Saturday&#39;, &#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;,
</span></span><span class="line"><span class="cl">       ...
</span></span><span class="line"><span class="cl">       &#39;Friday&#39;, &#39;Saturday&#39;, &#39;Sunday&#39;, &#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;,
</span></span><span class="line"><span class="cl">       &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Saturday&#39;, &#39;Sunday&#39;],
</span></span><span class="line"><span class="cl">      dtype=&#39;object&#39;, name=&#39;Date&#39;, length=4383)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　构建月份与对应季节间的映射字典。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">seasons = [1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 1]
</span></span><span class="line"><span class="cl">month_to_season = dict(zip(range(1,13), seasons))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">opsdtime.month.map(month_to_season)
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{1: 1, 2: 1, 3: 2, 4: 2, 5: 2, 6: 3, 7: 3, 8: 3, 9: 4, 10: 4, 11: 4, 12: 1}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Int64Index([1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
</span></span><span class="line"><span class="cl">            ...
</span></span><span class="line"><span class="cl">            1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
</span></span><span class="line"><span class="cl">           dtype=&#39;int64&#39;, name=&#39;Date&#39;, length=4383)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="周期性分析">周期性分析</h3>
<h4 id="重采样分析周期性">重采样分析周期性</h4>
<p>　　使用plot查看数据整体情况，电力消耗总量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd[&#39;Consumption&#39;].plot(figsize=(12,6))
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　<img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc523cae48.png"
    data-srcset="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc523cae48.png, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc523cae48.png 1.5x, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc523cae48.png 2x"
    data-sizes="auto"
    alt="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc523cae48.png"
    title="电力消耗整体情况" />
　　具体查看2007年的数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.loc[&#39;2007&#39;,&#39;Consumption&#39;].plot(figsize=(12,6))
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　<img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc5007e668.png"
    data-srcset="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc5007e668.png, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc5007e668.png 1.5x, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc5007e668.png 2x"
    data-sizes="auto"
    alt="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc5007e668.png"
    title="2007年电力消耗情况" />
　　使用groupby按变量season分组，并计算每个季节的用电量均值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.groupby(&#39;season&#39;)[&#39;Consumption&#39;].mean().plot()
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　<img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff8acc0.png"
    data-srcset="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff8acc0.png, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff8acc0.png 1.5x, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff8acc0.png 2x"
    data-sizes="auto"
    alt="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff8acc0.png"
    title="按season分组均值" />
　　使用groupby进行重采样，将数据按是星期几进行分组，并计算每组的用电量均值。这里使用lambda函数传入weekday进行分组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd.groupby(lambda x:x.weekday)[&#39;Consumption&#39;].mean().plot()
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　<img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff1a5f8.png"
    data-srcset="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff1a5f8.png, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff1a5f8.png 1.5x, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff1a5f8.png 2x"
    data-sizes="auto"
    alt="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ff1a5f8.png"
    title="按dayofweek分组均值" />
　　使用resample对风能发电数据进行降采样。按每个月重采样，并计算每月的均值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">wind = opsd[&#39;Wind&#39;].resample(&#39;M&#39;).mean()
</span></span><span class="line"><span class="cl">wind.plot(figsize=(12,6))
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　<img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e11ae48.png"
    data-srcset="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e11ae48.png, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e11ae48.png 1.5x, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e11ae48.png 2x"
    data-sizes="auto"
    alt="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e11ae48.png"
    title="按月重采样均值" /></p>
<h4 id="数据差分分析周期性">数据差分分析周期性</h4>
<p>　　在分析周期性的过程中，很重要的一点就是要消除数据的趋势性，常见的消除数据趋势的方法就是差分：计算连续数据点间的差异（这里特指一阶差分）。例如，t时刻的差分值：$\Delta d_t=d_t - d_{t-1}$。可以使用diff方法实现差分操作。<br>
　　例如，计算太阳能发电的差分序列并绘图：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd[&#39;Solar&#39;].diff().plot(figsize=(12,6))
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　<img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e0e3fd0.png"
    data-srcset="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e0e3fd0.png, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e0e3fd0.png 1.5x, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e0e3fd0.png 2x"
    data-sizes="auto"
    alt="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4e0e3fd0.png"
    title="一阶差分序列" />
　　也可以通过移动时间序列自行计算差分值。<br>
　　移动序列可以使用shift方法。shift方法可以沿着时间轴将数据前移或后移，保持索引不变。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd[&#39;Solar&#39;].tail()
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Date
</span></span><span class="line"><span class="cl">2017-12-27    16.530
</span></span><span class="line"><span class="cl">2017-12-28    14.162
</span></span><span class="line"><span class="cl">2017-12-29    29.854
</span></span><span class="line"><span class="cl">2017-12-30     7.467
</span></span><span class="line"><span class="cl">2017-12-31    19.980
</span></span><span class="line"><span class="cl">Freq: D, Name: Solar, dtype: float64
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd[&#39;Solar&#39;].shift(1).tail()
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Date
</span></span><span class="line"><span class="cl">2017-12-27    30.923
</span></span><span class="line"><span class="cl">2017-12-28    16.530
</span></span><span class="line"><span class="cl">2017-12-29    14.162
</span></span><span class="line"><span class="cl">2017-12-30    29.854
</span></span><span class="line"><span class="cl">2017-12-31     7.467
</span></span><span class="line"><span class="cl">Freq: D, Name: Solar, dtype: float64
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　两个序列相减即可得到原始数据的一阶差分序列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">dif = opsd[&#39;Solar&#39;]-opsd[&#39;Solar&#39;].shift(1)
</span></span><span class="line"><span class="cl">dif.plot(figsize=(12,6))
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　也可以通过设定shift方法中的参数freq移动索引而数据保持不变，例如指定时间移动一天。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd[&#39;Solar&#39;].shift(1,freq=&#39;d&#39;).tail()
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>Output:</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Date
</span></span><span class="line"><span class="cl">2017-12-28    16.530
</span></span><span class="line"><span class="cl">2017-12-29    14.162
</span></span><span class="line"><span class="cl">2017-12-30    29.854
</span></span><span class="line"><span class="cl">2017-12-31     7.467
</span></span><span class="line"><span class="cl">2018-01-01    19.980
</span></span><span class="line"><span class="cl">Freq: D, Name: Solar, dtype: float64
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="滚动窗口">滚动窗口</h3>
<p>　　与降采样类似，滚动窗口将数据拆分为时间窗口，并且对每个窗口中的数据使用诸如mean，median等函数进行聚合。但是，与降采样不同，滚动窗口以与数据相同的频率重叠和“滚动”，因此变换的时间序列与原始时间序列的频率相同。<br>
　　例如，设定窗口为7天，且以数据中心为基准点，则每一个数据对应的窗口将包含前面三天与后面三天。具体来看，2017-07-06对应的窗口就是2017-07-03到2017-07-09。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd[&#39;Wind&#39;].rolling(7).mean().plot(figsize=(12,6))
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　<img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4fcae400.png"
    data-srcset="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4fcae400.png, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4fcae400.png 1.5x, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4fcae400.png 2x"
    data-sizes="auto"
    alt="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4fcae400.png"
    title="7天滑窗均值" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd[&#39;Wind&#39;].rolling(30).mean().plot(figsize=(12,6))
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　当窗口范围中存在缺失值时，窗口将会返回为缺失值，可以设定min_periods为360，只需要对应窗口中有360个以上数据就可以，这样可以容忍一小部分的缺失数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">opsd[&#39;Wind&#39;].rolling(window=365,min_periods=360).mean().plot(figsize=(12,6))
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　<img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ddfe080.png"
    data-srcset="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ddfe080.png, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ddfe080.png 1.5x, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ddfe080.png 2x"
    data-sizes="auto"
    alt="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/0x7fbc4ddfe080.png"
    title="365天滑窗均值" /></p>
<h2 id="k-means-clustering-algorithm">K-means clustering algorithm</h2>
<p>　　一个简单的算法伪代码描述如下：
$$
\begin{aligned}
\hline
&amp;1:\ 选择K个点作为初始质心。\
&amp;2:\ repeat \
&amp;3:\ \quad 将每个点指派到最近的质心，形成K个簇。\
&amp;4:\ \quad 重新计算每个簇的质心。\
&amp;5:\ until 质心不发生变化。\
\hline
\end{aligned}
$$
　　相似度使用欧氏距离(Euclidean Distance)度量，给定两个样本$X=(x_1,x_2,&hellip;,x_n)$与$Y=(y_1,y_2,&hellip;,y_n)$，$X$和$Y$两个向量间的欧氏距离表示为：
$$
\begin{aligned}
dist_{ed}(X,Y)=\Vert X-Y \Vert ^2=\sqrt[2]{(x_1-y_1)^2+&hellip;+(x_n-y_n)^2}
\end{aligned}
$$</p>
<h3 id="python实现">Python实现</h3>
<p>　　距离计算函数<em>point_dist</em>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def point_dist(x,c): 
</span></span><span class="line"><span class="cl">    return np.linalg.norm(x-c)
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="iterrows-遍历方式实现">iterrows 遍历方式实现</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def k_means(X,k):
</span></span><span class="line"><span class="cl">    centers = X.sample(k).values #从数据集随机选择 K 个样本作为初始化的类中心，k 行 d 列
</span></span><span class="line"><span class="cl">    X_labels = np.zeros(len(X)) #样本的类别
</span></span><span class="line"><span class="cl">    error = 10e10
</span></span><span class="line"><span class="cl">    while(error &gt; 1e-6):
</span></span><span class="line"><span class="cl">        for i,x in X.iterrows():#指派样本类标签
</span></span><span class="line"><span class="cl">            X_labels[i] = np.argmin([point_dist(x,centers[i,:]) for i in range(k)])
</span></span><span class="line"><span class="cl">        centers_pre = centers
</span></span><span class="line"><span class="cl">        centers = X.groupby(X_labels).mean().values #更新样本均值，即类中心
</span></span><span class="line"><span class="cl">        error = np.linalg.norm(centers_pre - centers)#计算error
</span></span><span class="line"><span class="cl">    return X_labels, centers
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="apply-遍历方式实现">apply 遍历方式实现</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def k_means(X,k):
</span></span><span class="line"><span class="cl">    #初始化 K 个中心，从原始数据中选择样本
</span></span><span class="line"><span class="cl">    centers = X.sample(k).values
</span></span><span class="line"><span class="cl">    X_labels = np.zeros(len(X)) #样本的类别
</span></span><span class="line"><span class="cl">    error = 10e10
</span></span><span class="line"><span class="cl">    while(error &gt; 1e-6):
</span></span><span class="line"><span class="cl">        X_labels = X.apply(lambda r : np.argmin([point_dist(r,centers[i,:]) for i in range(k)]),axis=1)
</span></span><span class="line"><span class="cl">        centers_pre = centers
</span></span><span class="line"><span class="cl">        centers = X.groupby(X_labels).mean().values #更新样本均值，即类中心
</span></span><span class="line"><span class="cl">        error = np.linalg.norm(centers_pre - centers)#计算error
</span></span><span class="line"><span class="cl">    return X_labels, centers
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="矩阵运算方式实现">矩阵运算方式实现</h4>
<p>　　数据集表示成 $n \times d$ 矩阵 $\mathbf{X}$，其中 $n$ 为样本数量，$d$ 为样本的维度。 $k$ 个聚类中心表示成 $k \times d$ 矩阵 $\mathbf{C}$，$\mathbf{C}$ 每一行表示一个聚类中心。样本到 $k$ 个中心的距离表示成 $n \times k$ 矩阵 $\mathbf{D}$。</p>
<p>　　已知聚类中心，计算样本到中心距离，并将样本划分到距离最小的类的流程如下图所示。</p>
<p>　　<img
    class="lazyload"
    src="/svg/loading.min.svg"
    data-src="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/%E6%A0%B7%E6%9C%AC%E5%88%97%E8%A1%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B.jpg"
    data-srcset="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/%E6%A0%B7%E6%9C%AC%E5%88%97%E8%A1%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B.jpg, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/%E6%A0%B7%E6%9C%AC%E5%88%97%E8%A1%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B.jpg 1.5x, https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/%E6%A0%B7%E6%9C%AC%E5%88%97%E8%A1%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B.jpg 2x"
    data-sizes="auto"
    alt="https://hexo-img-meurice.oss-cn-beijing.aliyuncs.com/BDA%E5%A4%8D%E4%B9%A0/%E6%A0%B7%E6%9C%AC%E5%88%97%E8%A1%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B.jpg"
    title="样本列表计算流程" /></p>
<p>　　使用 Numpy 实现上述计算流程的代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for i in range(k):
</span></span><span class="line"><span class="cl">	D[:,i] = np.sqrt(np.sum(np.square(X - C[i,:]),axis=1))
</span></span><span class="line"><span class="cl">labels = np.argmin(D,axis=1)
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　得到样本的类标签后，聚类中心的更新流程为：1）根据类标签对样本进行分组；2）将聚类中心更新为每一组样本的均值。Python 实现的代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">C = X.groupby(labels).mean().values
</span></span></code></pre></td></tr></table>
</div>
</div><p>　　完整实现代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def k_means(X,k):
</span></span><span class="line"><span class="cl">    C = X.sample(k).values  #从数据集随机选择 K 个样本作为初始化的类中心，k 行 d 列
</span></span><span class="line"><span class="cl">    X_labels = np.zeros(len(X)) #记录样本的类别
</span></span><span class="line"><span class="cl">    error = 10e10 #停止迭代的阈值
</span></span><span class="line"><span class="cl">    while(error &gt; 1e-6):
</span></span><span class="line"><span class="cl">        D = np.zeros((len(X),k)) #样本到每一个中心的距离，n 行 k 列
</span></span><span class="line"><span class="cl">        for i in range(k):
</span></span><span class="line"><span class="cl">            D[:,i] = np.sqrt(np.sum(np.square(X - C[i,:]),axis=1))
</span></span><span class="line"><span class="cl">        labels = np.argmin(D,axis=1)
</span></span><span class="line"><span class="cl">        C_pre = C
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        temp_C = X.groupby(labels).mean() #更新样本均值，即类中心
</span></span><span class="line"><span class="cl">        C = np.zeros((k,X.shape[1]))
</span></span><span class="line"><span class="cl">        for i in temp_C.index:
</span></span><span class="line"><span class="cl">            C[i,:] = temp_C.loc[i,:].values
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        if C.shape == C_pre.shape:
</span></span><span class="line"><span class="cl">            error = np.linalg.norm(C_pre - C)#计算error
</span></span><span class="line"><span class="cl">        else:
</span></span><span class="line"><span class="cl">            print(C.shape, C_pre.shape)
</span></span><span class="line"><span class="cl">    return labels, C
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="logistic-regression">Logistic regression</h2>
<h3 id="线性回归">线性回归</h3>
<p>$$
\begin{aligned}
h_\theta(x)&amp;=\theta^Tx \
&amp;=\sum_{i=0}^n{\theta_i x_i} \
&amp;=\theta_0 + \theta_1 x_1 + \theta_2 x_2 + &hellip; + \theta_n x_n
\end{aligned}
$$</p>
<h3 id="sigmoid">sigmoid</h3>
<p>$$
\begin{aligned}
g(z)=\frac{1}{1+e^{-z}}
\end{aligned}
$$</p>
<h3 id="逻辑回归公式">逻辑回归公式</h3>
<p>　　线性回归公式带入Sigmoid即得：
$$
\begin{aligned}
h_\theta(x)=\frac{1}{1+e^{-{\theta^Tx}}}
\end{aligned}
$$</p>
<h3 id="损失函数">损失函数</h3>
<p>　　对数形式的似然函数如下：<br>
$$
\begin{aligned}
logL(\theta)=\sum_{i=1}^n{log(p(x_i;\theta))}
\end{aligned}
$$
　　用sigmoid函数表示0-1中取1的概率，损失函数可以定义为：
$$
\begin{aligned}
y&amp;=0时，Cost(h_\theta(x),y)=-log(1-h_\theta(x)) \
y&amp;=1时，Cost(h_\theta(x),y)=-log(h_\theta(x))
\end{aligned}
$$
　　损失函数的要求是预测结果与真实结果越相近，函数值越小，故在前面加上负号。取对数和上面提到的最大似然函数有关，不影响原函数的单调性，且会放大概率之间的差异，更好的区分各个样本的类别。<br>
　　故逻辑回归的损失函数如下：
$$
\begin{aligned}
J(\theta)=-\frac{1}{m}\sum_{i=1}^m{[y^{(i)}logh_\theta(x^{(i)})+(1-y^{(i)})log(1-h_\theta(x^{(i)}))]}
\end{aligned}
$$</p>
<h3 id="梯度下降">梯度下降</h3>
<p>　　要求出最优参数$\theta$，需要最小化$J(\theta)$，更新参数：
$$
\begin{aligned}
\theta_j := \theta_j-\alpha \frac{\partial J(\theta)}{\partial \theta_j}
\end{aligned}
$$
　　sigmoid函数求导：
$$
\begin{aligned}
\frac{\partial g(z)}{\partial z}=g(z)(1-g(z))
\end{aligned}
$$
　　对g(\theta^Tx)求导：
$$
\begin{aligned}
\frac{\partial g(\theta^Tx)}{\partial z}=g(\theta^Tx)(1-g(\theta^Tx))x_j^{(i)}
\end{aligned}
$$
　　<strong>损失函数求导：</strong>
$$
\begin{aligned}
\frac{\partial J(\theta)}{\partial \theta_j}&amp;= &hellip;\
&amp;=\frac{1}{m}\sum_{i}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}
\end{aligned}
$$
　　得到逻辑回归的梯度下降更新公式：
$$
\begin{aligned}
\theta_j := \theta_j-\alpha  \frac{1}{m}\sum_{i}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}
\end{aligned}
$$</p>
<h3 id="伪代码描述">伪代码描述</h3>
<p>$$
\begin{aligned}
\hline
&amp;1:\ 初始化回归系数。\
&amp;2:\ repeat \
&amp;3:\ \quad 计算梯度\frac{\partial J(\theta)}{\partial \theta}。\
&amp;4:\ \quad \theta:=\theta+\alpha * \frac{\partial J(\theta)}{\partial \theta}。\
&amp;5:\ until 收敛 \  or \  max_loop。\
&amp;6:\ return\ \theta \
\hline
\end{aligned}
$$</p>
<h3 id="python实现-1">Python实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class LR:
</span></span><span class="line"><span class="cl">    def __init__(self, alpha=0.01, max_iter=100):
</span></span><span class="line"><span class="cl">        self.alpha = alpha
</span></span><span class="line"><span class="cl">        self.max_iter = max_iter
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    def fit(self, X, y):
</span></span><span class="line"><span class="cl">        X = np.mat(X)  # (rows,cols)
</span></span><span class="line"><span class="cl">        m, n = np.shape(X)
</span></span><span class="line"><span class="cl">        y = np.mat(y).T  # (rows,cols)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        self.weight = np.ones((n, 1))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        for i in range(self.max_iter):
</span></span><span class="line"><span class="cl">            h = self.sigmoid(X * self.weight)
</span></span><span class="line"><span class="cl">            error = y - h
</span></span><span class="line"><span class="cl">            self.weight = self.weight + self.alpha * X.T * error
</span></span><span class="line"><span class="cl">```r
</span></span></code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title=2021-05-25&#32;13:39:00>更新于 May 25, 2021</span>
      </div>
      <div class="post-info-license"><span><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
    </div>
    <div class="post-info-line">
      <div class="post-info-md"><span><a
  href="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/index.md"
  
    title="阅读原始文档"
  
  
  
  
  
    class="link-to-markdown"
  
  
>阅读原始文档</a></span></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/" data-title="大数据处理技术复习要点总结"><i class="fa-brands fa-twitter fa-fw"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/"><i class="fa-brands fa-facebook-square fa-fw"></i></a>
  <a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/" data-title="大数据处理技术复习要点总结" data-web><i class="fa-brands fa-whatsapp fa-fw"></i></a>
  <a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/" data-title="大数据处理技术复习要点总结"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/" data-title="大数据处理技术复习要点总结"><i class="fa-brands fa-weibo fa-fw"></i></a>
  <a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/" data-title="大数据处理技术复习要点总结" data-description=""><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></i></a>
  <a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/" data-title="大数据处理技术复习要点总结" data-description=""><i class="fa-brands fa-blogger fa-fw"></i></a>
  <a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93-pandas/" data-title="大数据处理技术复习要点总结"><i class="fa-brands fa-evernote fa-fw"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/2021%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8Cfintech%E7%B2%BE%E8%8B%B1%E8%AE%AD%E7%BB%83%E8%90%A5-%E6%95%B0%E6%8D%AE%E8%B5%9B%E9%81%93/" class="prev" rel="prev" title="2021招商银行FinTech精英训练营 数据赛道"><i class="fa-solid fa-angle-left fa-fw"></i>2021招商银行FinTech精英训练营 数据赛道</a>
      <a href="/2021%E4%B8%AD%E5%9B%BD%E9%AB%98%E6%A0%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A4%A7%E8%B5%9B%E5%BE%AE%E4%BF%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8C%91%E6%88%98%E8%B5%9B/" class="next" rel="next" title="2021中国高校计算机大赛 微信大数据挑战赛">2021中国高校计算机大赛 微信大数据挑战赛<i class="fa-solid fa-angle-right fa-fw"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">
          由<a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer" title="Hugo %v">Hugo</a>
          ×
          <a href="https://github.com/Lruihao/FixIt" target="_blank" rel="external nofollow noopener noreffer" title="FixIt %v"><img class="fixit-icon" src="/images/fixit.svg" alt="FixIt logo" />&nbsp;FixIt</a>
          强力驱动
          
        </div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
            <span itemprop="copyrightYear">2020 - 2022</span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div><div class="footer-line beian"><span class="icp footer-divider">鄂ICP备20012765号</span></div></div>
  </footer></div><div class="widgets">
  <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
      <i class="fa-solid fa-arrow-up fa-fw"></i>
    </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
      <i class="fa-solid fa-comment fa-fw"></i>
    </a>
  </div><a
  href="https://github.com/yzhn16"
  
    title="在 GitHub 上查看源代码"
  
  
    
    
    target="_blank"
  
  
    rel="external nofollow noopener noreffer"
  
  
  
    class="github-corner right d-none-mobile"
  
  
><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><div id="mask"></div>
</div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js" defer></script><script type="text/javascript" src="/lib/lunr/lunr.min.js" defer></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js" defer></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js" defer></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js" async defer></script><script type="text/javascript" src="/lib/sharer/sharer.min.js" async defer></script><script type="text/javascript" src="/lib/katex/katex.min.js" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.js" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.js" defer></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":10},"comment":{},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"enablePWA":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js" defer></script><script type="text/javascript" src="/js/_custom.min.js" defer></script></body>
</html>
